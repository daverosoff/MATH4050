<?xml version="1.0" encoding="utf-8"?>
<section xml:id="section-1" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>The Construction of the Real Numbers</title>
  <introduction>
    <p>We have to start from somewhere, but assuming as little as we can,
      we'll generate the real numbers out of just the natural numbers and
      some basic mathematical constructs.
    </p>
  </introduction>
  <subsection xml:id="subsection-1">
    <title>Natural numbers and integers</title>
    <axiom xml:id="axiom-peano">
      <statement>
        <p>
          There is a set <m>\N</m>, whose elements are called <term>natural numbers</term>,
          and a function <m>s \colon \N \to \N</m>, satisfying:
          <ol marker="1.">
            <li>
              There is an element <m>1 \in \N</m>.
            </li>
            <li>
              There is no <m>n \in \N</m> such that <m>s(n) = 1</m>.
            </li>
            <li>
              The function <m>s</m> is injective (this means that
              <m>s(n) = s(m)</m> only if <m>n = m</m>).
            </li>
            <li xml:id="axiom-induction">
              <title>Principle of induction</title>
              <p>
                Suppose <m>S \subseteq \N</m> is a subset such that
                <m>1 \in S</m> and if <m>n \in S</m> then <m>n+1 \in S</m>.
                Then <m>S = \N</m>.
              </p>
            </li>
          </ol>
          We call <m>s</m> the <term>successor function</term>. Informally
          think of <m>s(n) = n+1</m>.
        </p>
      </statement>
    </axiom>
    <proposition xml:id="prop-predecessors-are-unique">
      <statement>
        <p>
          If <m>n \in \N</m> and <m>n \ne 1</m>, there is a unique <m>m \in \N</m>
          such that <m>s(m) = n</m>.
        </p>
      </statement>
      <proof>
        <p>
          Let <m>
            A = \{ n \in \N : n = 1\text{ or }n = s(m)\text{ for some }m \in N \}
            \subseteq \N
          </m>. Then <m>1 \in A</m> and if <m>n \in A</m>, then <m>s(n) \in A</m>,
          so <m>A = \N</m> by <xref ref="axiom-induction"/>. Hence, if <m>n \in \N</m>
          and <m>n \ne 1</m>, then <me>n = s(m)</me> for some <m>m \in \N</m>, which is
          unique since <m>s</m> is injective. Indeed, if <m>n = s(m')</m>, then
          <m>s(m) = s(m')</m>, therefore <me>m = m'</me>.
        </p>
      </proof>
    </proposition>
    <remark>
      <p>
        We set <m>2 = s(1)</m>, <m>3 = s(2)</m>, and so on, so that <m>\N = \{ 1, 2, 3, \ldots \}</m>.
      </p>
    </remark>
    <definition xml:id="def-addition">
      <statement>
        <p>
          We define a binary operation <m>+ \colon \N \times \N \to \N</m> by
          <ol marker="1.">
            <li>For all <m>n \in \N</m>, <m>n + 1 = s(n)</m>.</li>
            <li>For all <m>n, m \in N</m>, <m>n + s(m) = s(n + m)</m>.</li>
          </ol>
        </p>
      </statement>
    </definition>
    <p>
      Observe that this is a recursive definition: <md>
        <mrow>n+1 \amp = s(n)</mrow>
        <mrow>n+2 \amp = n + s(1) = s(n+1) = s(s(n))</mrow>
        <mrow>n+3 \amp = n + s(2) = s(n+2) = s(n + s(1)) = s(s(n + 1)) = s(s(s(n)))</mrow>
      </md>
    </p>
    <proposition xml:id="prop-addition-associative">
      <statement>
        <p>
          For all <m>a, b, c \in \N</m>, we have <me>(a + b) + c = a + (b + c)</me>.
        </p>
      </statement>
      <proof>
        <p>
          Let <m>A = \{ c \in \N \colon (a + b) + c = a + (b + c)\text{ for all }a, b \in \N\}</m>. We
          will show that <m>A = \N</m> using induction <xref ref="axiom-induction"/>. Indeed, for
          <m>a, b \in \N</m>, we have
          <me>(a + b) + 1  = s(a + b) = a + s(b) = a + (b + 1)</me>,
          so <m>1 \in A</m>. Now suppose <m>c \in A</m>. Then for <m>a, b \in \N</m>, we have
          <md>
            <mrow>(a + b) + s(c) \amp = s((a + b) + c) = s(a + (b + c))</mrow>
            <mrow> \amp = a + s(b + c) = a + (b + s(c))</mrow>
          </md>. This shows <m>s(c) \in A</m> and the proof by induction is complete.
        </p>
      </proof>
    </proposition>
    <definition xml:id="def-multiplication">
      <statement>
        <p>
          We define another operation <m>\cdot \colon \N \times \N \to \N</m> by:
          <ol marker="1.">
            <li>
              <p>
                For all <m>n \in \N</m>, <m>n \cdot 1 = n</m>.
              </p>
            </li>
            <li>
              <p>
                For all <m>n, m \in \N</m>, <m>n \cdot s(m) = n \cdot m + n</m>.
              </p>
            </li>
          </ol>
        </p>
      </statement>
    </definition>
    <p>
      Explicitly, <md>
        <mrow>n \cdot 2 \amp = n \cdot s(1) = n \cdot 1 + n = n + n</mrow>
        <mrow>n \cdot 3 \amp = n \cdot s(2) = n \cdot 2 + n = (n + n) + n</mrow>
      </md> and so on.
    </p>
    <proposition xml:id="prop-more-field-axioms">
      <statement>
        <p>
          Let <m>a, b, c \in \N</m>.
          <ol>
            <li>
              <p>
                <m>a + b = b + a</m>.
              </p>
            </li>
            <li>
              <p>
                If <m>a + c = b + c</m>, then <m>a = b</m>.
              </p>
            </li>
            <li>
              <p>
                <m>a \cdot b = b \cdot a</m>.
              </p>
            </li>
            <li>
              <p>
                <m>a \cdot (b \cdot c) = (a \cdot b) \cdot c</m>.
              </p>
            </li>
            <li xml:id="li-multiplication-distributes">
              <p>
                <m>a \cdot (b + c) = a \cdot b + a \cdot c</m>.
              </p>
            </li>
            <li>
              <p>
                If <m>a \cdot c = b \cdot c</m>, then <m>a = c</m>.
              </p>
            </li>
          </ol>
        </p>
      </statement>
    </proposition>
    <proof>
      <p>
        Items 1<ndash/>4 and 6 are left to the reader. Items 2 and 6
        appear on <xref ref="subsec-hw-01" text="title"/>
        as <xref ref="hw-01-cancel-addition"/>
        and <xref ref="hw-01-cancel-multiplication"/>.
      </p>
      <p>
        Proof of <xref ref="li-multiplication-distributes"/> only. Let
        <me>
          A = \{ c \in \N : a \cdot (b + c) = a \cdot b + a \cdot c \text{ for all } a, b \in \N \}
        </me>. For <m>a, b \in \N</m>, we have
        <me>
          a \cdot (b + 1) = a \cdot s(b) = a \cdot b + a = a\cdot b + a\cdot 1
        </me>, so <m>1 \in A</m>.
      </p>
      <p>
        Now suppose <m>c \in A</m> and let <m>a, b \in \N</m>, so that <m>a \cdot (b+c) = a\cdot b + a \cdot c</m>.
        Then <md>
          <mrow>a \cdot (b + s(c)) \amp = a \cdot s(b + c) = a \cdot (b + c) + a</mrow>
          <mrow>\amp = (a\cdot b + a\cdot c) + a = a\cdot b + a \cdot c + a</mrow>
          <mrow>\amp = a\cdot b + (a\cdot c + a\cdot 1 )= a\cdot b + a(c \cdot 1) = a \cdot b + a\cdot s(c)</mrow>
        </md>, which shows <m>s(c) \in A</m> so that <m>A = \N</m>.
      </p>
    </proof>
    <p>
      Now we give the <term>standard form of induction</term>. Let <m>P(n)</m> be a statement about a
      natural number <m>n</m> that is either true or false. If <m>P(1)</m> is true and if, whenever
      <m>P(n)</m> is true we also have <m>P(n+1)</m> is true, then <m>P(n)</m> is true for all <m>n \in \N</m>.
    </p>
    <definition xml:id="def-less-than">
      <statement>
        <p>
          If <m>m, n \in \N</m>, we say <m>m</m> is <term>less than</term> <m>n</m>, and write <m>m \lt n</m>,
          if <m>n = m + k</m> for some <m>k \in \N</m>. We write <m>m \leq n</m> if we only wish to assert that
          <m>m \lt n</m> or <m>m = n</m>.
        </p>
      </statement>
    </definition>
    <proposition xml:id="prop-order-axioms">
      <statement>
        <p>
          Let <m>a, b, c \in \N</m>.
          <ol>
            <li>
              <p>
                We have <m>a \leq a</m>, but <m>a \not\lt a</m>.
              </p>
            </li>
            <li>
              <p>
                If <m>a \lt b</m> and <m>b \lt c</m>, then <m>a \lt c</m>, and similarly for <m>\leq</m>.
              </p>
            </li>
            <li>
              <p>
                If <m>a \leq b</m> and <m>b \leq a</m>, then <m>a = b</m>.
              </p>
            </li>
            <li>
              <p>
                Exactly one of <m>a \lt b</m> or <m>a = b</m> or <m>b \lt a</m> is true.
              </p>
            </li>
            <li xml:id="li-addition-preserves-order">
              <p>
                We have <m>a \lt b</m> if and only if <m>a + c \lt b + c</m>.
              </p>
            </li>
            <li>
              <p>
                We have <m>a \lt b</m> if and only if <m>a \cdot c \lt b \cdot c</m>.
              </p>
            </li>
          </ol>
        </p>
      </statement>
      <proof>
        <p>
          Items 1, 3, 5, and 6 are left to the reader. <xref ref="li-addition-preserves-order"/>
          appears on <xref ref="subsec-hw-01" text="title"/>
          as <xref ref="hw-01-addition-preserves-order"/>.
        </p>
        <p>
          Proof of 2. Suppose that <m>a \lt b</m> and <m>b \lt c</m>. Then we have
          <m>b = a + k</m> and <m>c = b + \ell</m> for some <m>k, \ell \in \N</m>.
          Then <me>
            c = b + \ell = (a + k) + \ell = a + (k + \ell)
          </me> with <m>k + \ell \in \N</m>, so <m>a \lt c</m>.
        </p>
        <p>
          Proof of 4. First we will show that no more than one of the statements <md>
            <mrow>a \amp \lt b</mrow>
            <mrow>a \amp = b</mrow>
            <mrow>b \amp \lt a</mrow>
          </md> is true. Suppose first that <m>a \lt b</m>. Then <m>b = a + k</m> for
          some <m>k \in \N</m>. <xref ref="lem-addition-not-nilpotent"/> says
          that <m>m \ne m + n</m> for all <m>m, n \in \N</m>. Thus,
          we find <m>b = a + k \ne a</m>. Similarly, if <m>b \lt a</m> then <m>a \ne b</m>.
        </p>
        <p>
          Now if <m>a \lt b</m> and <m>b \lt a</m> then <m>b = a + k</m> and <m>a = b + \ell</m>
          for some <m>k, \ell \in \N</m>, so <me>
            b = (b + \ell) + k = b + (\ell + k)
          </me>, but this implies <m>b \ne b</m>, a contradiction. Similarly, if <m>a = b</m>,
          then <m>a \not\lt b</m> and <m>b \not\lt a</m>. This shows at most one of the statements
          is true.
        </p>
        <p>
          To show at most one of the statements is true, let's fix <m>a \in \N</m> and let
          <m>P(b)</m> be the statement <q><m>a \lt b</m> or <m>a = b</m> or <m>b \lt a</m></q>.
          If <m>a \ne 1</m>, then <m>a = s(k) = 1 + k</m> for some <m>k \in \N</m>, so <m>1 \lt a</m>
          and we have established <m>P(1)</m>. Now, let's suppose that <m>b \in \N</m> and that
          <m>P(b)</m> is true, meaning that <m>a \lt b</m> or <m>a = b</m> or <m>b \lt a</m>.
        </p>
        <p>
          Suppose first that <m>a \lt b</m>. Then <m>b = a + k </m> for some <m>k \in \N</m>,
          so <m>s(b) = s(a+k) = a + s(k)</m>. This shows that <m>a \lt s(b)</m>, so <m>P(b+1)</m>
          is true in this case.
        </p>
        <p>
          Suppose next that <m>a = b</m>. Then <m>s(b) = b + 1 = a + 1</m>, so <m>a \lt s(b)</m>
          and <m>P(b+1)</m> is true as before.
        </p>
        <p>
          Finally, suppose that <m>b \lt a</m>. Then <m>a = b + k</m> for some <m>k</m>. If
          <m>k = 1</m>, then <m>a = b + 1 = s(b)</m>, so <m>P(b+1)</m> is true. If <m>k \ne 1</m>,
          then <m>k = s(\ell)</m> for some <m>\ell \in \N</m> and <me>
            a = b + s(\ell) = b + \ell + 1 = (b + 1) + \ell = s(b) + \ell
          </me>. This shows that <m>a \lt s(b)</m>, and therefore <m>P(b+1)</m> is true in this
          case as well.
        </p>
        <p>
          We have shown that <m>P(b) \implies P(b+1)</m> for all <m>b\in \N</m>, which concludes
          the proof by induction.
        </p>
      </proof>
    </proposition>
    <lemma xml:id="lem-successor-fixpoint-free">
      <statement>
        <p>
          The successor function <m>s \colon \N \to \N</m> has no fixed point, that is,
          for all <m>n \in \N</m> we have <m>n \ne n + 1</m>.
        </p>
      </statement>
      <proof>
        <p>
          Left to the reader (<xref ref="hw-01-successor-fixpoint-free"/>).
        </p>
      </proof>
    </lemma>
    <lemma xml:id="lem-addition-not-nilpotent"> 
      <statement>
        <p>
          For all <m>n, k \in \N</m>, we have <m>n \ne n + k</m>.
        </p>
      </statement>
      <proof>
        <p>
          Left to the reader (<xref ref="hw-01-addition-not-nilpotent"/>).
        </p>
      </proof>
    </lemma>
    <theorem xml:id="thm-well-ordering">
      <title>The well-ordering principle</title>
      <statement>
        <p>
          If <m>A \subseteq \N</m> is nonempty, then <m>A</m> has a <term>least element</term>.
          That is, there exists <m>a \in A</m> such that <m>a \leq b</m> for all <m>b \in A</m>.
        </p>
      </statement>
    </theorem>

  </subsection>
  <subsection xml:id="subsec-the-integers">
    <title>The Integers</title>
    <definition xml:id="def-relation">
      <statement>
        <p>
          A <term>relation</term> on a set <m>A</m> is a subset 
          <m>R</m> of the Cartesian product
          <m>A \times A</m>. If <m>(x,y) \in R</m>, we write
          <me>
            x \sim_R y
          </me>
          or simply <m>x \sim y</m> if the relation <m>R</m> is understood.
          Sometimes we abuse notation and identify the equivalence operator
          <m>\sim</m> with the relation <m>R</m>.
        </p>
      </statement>
    </definition>
    <definition xml:id="def-equivalence-relation">
      <statement>
        <p>
          A relation <m>\sim</m> is called an <term>equivalence relation</term>
          if 
          <ol marker="1.">
            <li>
              <p>
                It is <em>reflexive</em>: <m>x \sim x</m> for all <m>x \in A</m>.
              </p>
            </li>
            <li>
              <p>
                It is <em>symmetric</em>: If <m>x \sim y</m> then <m>y \sim x</m>
                for all <m>x, y \in A</m>.
              </p>
            </li>
            <li>
              <p>
                It is <em>transitive</em>: If <m>x \sim y</m> and <m>y \sim z</m>
                then <m>x \sim z</m> for all <m>x, y, z \in A</m>.
              </p>
            </li>
          </ol>
        </p>
      </statement>
    </definition>
    <example xml:id="ex-equiv-rel-01">
      <p>
        Let <m>A = \{ 1, 2, 3 \}</m> and let 
        <m>R = \{ (1, 1), (2, 2), (3, 3), (2, 3), (3, 2) \}</m>.
        Then observe:
        <md>
          <mrow>(1, 1), (2, 2), (3, 3) \in R \amp \implies \text{reflexive}</mrow>
          <mrow>(2, 3), (3, 2) \in R \amp \implies \text{symmetric}</mrow>
          <mrow>(2, 3), (3, 2) \in R \text{ and } (2, 2) \in R \amp</mrow>
          <mrow>(3, 2), (2, 3) \in R \text{ and } (3, 3) \in R \amp</mrow>
          <mrow>(2, 2), (2, 3) \in R \text{ and } (2, 3) \in R \amp</mrow>
          <mrow>(3, 3), (3, 2) \in R \text{ and } (3, 2) \in R \amp \text{transitive}</mrow>
        </md>, so <m>R</m> is an equivalence relation.
      </p>
    </example>
    <definition xml:id="def-partition-of-set">
      <statement>
        <p>
          Let <m>A</m> be a set. A collection of subsets <m>A_i</m> of <m>A</m>
          is called a <term>partition</term> of <m>A</m> if each element of
          <m>A</m> belongs to exactly one of the <m>A_i</m>.
        </p>
      </statement>
    </definition>
    <p>
      Notice that <xref ref="def-partition-of-set"/> does not require the
      elements of a partition to be finite in number. In other words, we can
      partition a set into infinitely many parts.
    </p>
    <lemma xml:id="lem-partitions-parts-disjoint-equal">
      <statement>
        <p>
          Suppose <m>A</m> is partitioned into the subsets <m>A_i</m>. Then
          we have, for all <m>i</m>, <m>j</m>:
          <men xml:id="eq-partitions-parts-disjoint-equal">
            A_i \cap A_j = \varnothing \text{ or } A_i = A_j
          </men>.
          This is usually summarized by saying 
          <q>
            The parts of a partition
            are either equal or disjoint.
          </q>
        </p>
        <p>
          The converse is also true, namely, if <m>A_i</m> is a collection 
          of subsets of <m>A</m>
          satisfying <xref ref="eq-partitions-parts-disjoint-equal"/>
          and <m>\bigcup A_i = A</m>,
          then the <m>A_i</m> are a partition of <m>A</m>.
        </p>
      </statement>
      <proof>
        <p>
          Suppose first that the <m>A_i</m> partition <m>A</m>.
          Then each element of <m>A</m> has to belong to exactly one of the
          <m>A_i</m>. Now suppose <m>a</m>
          is an element of <m>A_i \cap A_j</m>. Then, because <m>a</m> belongs
          to exactly one of the <m>A_i</m>, we must have <m>A_i = A_j</m>.
          This shows that the <m>A_i</m> satisfy 
          <xref ref="eq-partitions-parts-disjoint-equal"/>.
        </p>
        <p>
          On the other hand, suppose that <m>A_i</m> are some subsets of
          <m>A</m> satisfying <xref ref="eq-partitions-parts-disjoint-equal"/>.
          Then let <m>a \in A</m>; it is enough to show that <m>a</m> belongs
          to exactly one of the <m>A_i</m>. If we suppose <m>a</m> belongs to
          two of the <m>A_i</m>, say <m>a \in A_i</m> and <m>a \in A_j</m>, then
          by <xref ref="eq-partitions-parts-disjoint-equal"/> we have at once
          that <m>A_i = A_j</m>. So <m>a</m> cannot belong to more than one
          of the <m>A_i</m>. On the other hand, the union of the <m>A_i</m> 
          is equal to <m>A</m>, hence it certainly contains <m>a</m>, which
          means that <m>a</m> belongs to at least one of the <m>A_i</m>.
        </p>
        <p>
          Thus we have shown that <m>a</m> belongs to exactly one of the 
          <m>A_i</m>, and so the <m>A_i</m> are a partition of <m>A</m>, 
          as required.
        </p>
      </proof>
    </lemma>
    <proposition xml:id="prop-equivalence-relations-partition">
      <statement>
        <p>
          Let <m>\sim</m> be an equivalence relation on a set <m>A</m>. For each
          <m>a \in A</m> we define a subset <m>[a] = \{ x \in A : x \sim a \}</m>,
          called the <term>equivalence class</term> of <m>a</m> under <m>\sim</m>.
          The set of all such equivalence classes is a partition of <m>A</m>.
        </p>
      </statement>
      <proof>
        <p>
          We proceed according to <xref ref="lem-partitions-parts-disjoint-equal"/>
          and show that the equivalence classes 
          satisfy <xref ref="eq-partitions-parts-disjoint-equal" /> and that
          their union is <m>A</m>.
        </p>
        <p>
          Suppose <m>x \in [a]</m> and <m>x \in [b]</m> for some <m>a, b \in A</m>.
          Then by definition we have <m>x \sim a</m> and <m>x \sim b</m>. Thus
          <m>a \sim x</m> and hence <m>a \sim b</m>. It follows that 
          <me>[a] \subseteq [b]</me>. Indeed, if <m>y \sim a</m>, then also
          <m>y \sim x</m> (because <m>a \sim x</m> and <m>\sim</m> is an
          equivalence relation). Thence <m>y \sim b</m> because <m>x \sim b</m>
          and finally this means that <m>y \in [b]</m>. It follows by a symmetric
          argument that <m>[b] \subseteq [a]</m>. Hence <m>[a] = [b]</m>. 
        </p>
        <p>
          This shows that for all <m>a, b \in A</m>, either 
          <m>[a] \cap [b] = \varnothing</m> or <m>[a] = [b]</m>, which is the 
          content of <xref ref="eq-partitions-parts-disjoint-equal"/>.
        </p>
        <p>
          To see that the union of the equivalence classes is <m>A</m>, 
          we just notice that each <m>a \in A</m> is certainly a member
          of its own equivalence class <m>[a]</m>, because <m>A</m> is an
          equivalence relation. This concludes the proof.
        </p>
      </proof>
    </proposition>
    <example>
      <p>
        For the equivalence relation <m>R</m> on the set <m>A</m> of 
        <xref ref="ex-equiv-rel-01"/>, namely
        <md>
          <mrow>A \amp = \{ 1, 2, 3 \}</mrow>
          <mrow>R \amp = \{ (1, 1), (2, 2), (3, 3), (2, 3), (3, 2) \}</mrow>
        </md>,
        we have the following equivalence classes:
        <me>
          [1] = \{1\}, [2] = \{2, 3\}, [3] = \{2, 3\}
        </me>.
        The partition of <m>A</m> associated to the equivalence relation is
        <me>
          A = \{1\} \cup \{2, 3\}
        </me>.
      </p>
    </example>
    <p>
      Equivalence relations are a powerful method of constructing new sets
      from old. We can look at the set of equivalence classes as a new
      mathematical object. This is illustrated in diabolically clever fashion
      by <xref ref="def-defining-relation-minus"/>.
    </p>
    <definition xml:id="def-defining-relation-minus">
      <statement>
        <p>
          We define a relation <m>\sim</m> on the set <m>\N \times \N</m>
          by <me>
            (a, b) \sim (c, d) \text{ if } a + d = b + c
          </me>.
        </p>
        <p>
          This looks strange, but it is concocted quite precisely. We are trying
          to construct the negative integers out of thin air. The idea is to
          represent a number like <m>-3</m> as the class of all pairs
          <m>(a, b) \in \N \times \N</m> where <m>a + 3 = b</m>. It's the
          idea of being three less than something.
        </p>
      </statement>
    </definition>
    <proposition xml:id="prop-minus-relation-equiv-relation">
      <statement>
        <p>
          The relation <m>\sim</m> is an equivalence relation.
        </p>
      </statement>
      <proof>
        <p>
          Let <m>a, b \in \N</m>. Then <m>a + b = b + a</m>, so we have
          <m>(a, b) \sim (a, b)</m>. Thus the relation is reflexive.
        </p>
        <p>
          Next let us suppose that <m>(a, b) \sim (c, d)</m> for some
          <m>a, b, c, d \in \N</m>. Then <m>a + d = b + c</m>. It follows
          that <m>c + b = d + a</m>, so <m>(c, d) \sim (a, b)</m>.
          Thus the relation is symmetric.
        </p>
        <p>
          Finally, let us suppose that <m>(a, b) \sim (c, d)</m> and
          <m>(c, d) \sim (e, f)</m> for some <m>a, b, c, d, e, f \in \N</m>.
          Then <m>a + d = b + c</m> and <m>c + f = d + e</m>. Adding,
          we find
          <md>
            <mrow>a + d + c + f   \amp = b + c + d + e</mrow>
            <mrow>a + f + (c + d) \amp = b + e + (c + d)</mrow>
            <mrow>a + f \amp = b + e</mrow>
          </md> from which it follows at once that <m>(a, b) \sim (e, f)</m>
          and the relation is transitive.
        </p>
      </proof>
    </proposition>
    <definition xml:id="def-integers">
      <statement>
        <p>
          The set of <term>integers</term>, denoted <m>\Z</m>, is the set
          of equivalence classes of <m>\sim</m> in the set <m>\N \times \N</m>.
        </p>
        <p>
          That is, 
          <me>
            \Z = \{ [(a, b)] : a, b \in \N \}
          </me>.
          We define the elements <m>\overline{0} \in \Z</m> 
          and <m>\overline{1} \in \Z</m> by 
          <md>
            <mrow>\overline{0} \amp = [(1, 1)] = \{ (a, b) \in \N \times \N : a = b \} </mrow>
            <mrow>\overline{1} \amp = [(2, 1)] = \{ (a, b) \in \N \times \N : a = 1 + b \}</mrow>
          </md>.
        </p>
      </statement>
    </definition>
    <p>
      Having defined the integers, it's now our duty to give them their familiar operations and
      show that these extend the operations on <m>\N</m>. This is done in a standard way below.
    </p>
    <definition xml:id="def-addition-integers">
      <statement>
        <p>
          We define the operation <m>+ \colon \Z \to \Z</m> by 
          <men xml:id="eq-addition-integers-01">
            [(a, b)] + [(c, d)] = [(a + c, b + d)].
          </men>
          This definition requires a short proof to be valid. So it is only
          provisional for now.
        </p>
      </statement>
    </definition>
    <p>
      For <xref ref="def-addition-integers"/> to be valid, we have to show
      that the right-hand side of <xref ref="eq-addition-integers-01"/>
      doesn't depend on our choices of <m>a, b, c, d</m>. If we let those
      numbers vary within their equivalence classes, the right-hand-side must
      not change. When this is established, we say that addition of integers
      is <em>well-defined</em>.
    </p>
    <proposition xml:id="prop-addition-integers-well-defined">
      <statement>
        <p>
          Let's suppose that <m>[(a, b)] = [(a', b')]</m>, so that 
          <m>(a', b')</m> is another member of the equivalence class
          <m>[(a, b)]</m>. Similarly, let's take <m>(c', d')</m> so that
          <m>[(c', d')] = [(c, d)]</m>. Then it doesn't matter which we use
          to compute <m>[(a, b)] + [(c, d)]</m>, because
          <me>
            [(a + c, b + d)] = [(a' + c', b' + d')]
          </me>.
        </p>
      </statement>
      <proof>
        <p>
          Since <m>[(a, b)] = [(a', b')]</m> and <m>[(c, d)] = [(c', d')]</m>,
          we have <me>
            a + b' = b + a' \quad \text{ and } \quad c + d' = d + c'
          </me>. Adding, we find
          <md>
            <mrow>a + c + b' + d' \amp = b + d + a' + c'</mrow>
            <mrow>(a + c) + (b' + d') \amp = (b + d) + (a' + c')</mrow>
          </md>, which means that 
          <m>[(a + c), (b + d)] = [(a' + c', b' + d')]</m>, as required.
        </p>
      </proof>
    </proposition>
    <definition xml:id="def-negation-subtraction-integers">
      <statement>
        <p>
          Define <term>negation</term> <m>- \colon \Z \to \Z</m> by
          <me>
            -[(a, b)] = [(b, a)].
          </me>
        </p>
        <p>
          Define <term>subtraction</term> <m>- \colon \Z \times \Z \to \Z</m>
          by <me>
            [(a, b)] - [(c, d)] = [(a, b)] + (-[(c, d)])
          </me>.
        </p>
      </statement>
    </definition>
    <proposition xml:id="prop-neg-sub-integers-well-defined">
      <statement>
        <p>
          The operations of <xref ref="def-negation-subtraction-integers"/>
          are well-defined.
        </p>
      </statement>
      <proof>
        <p>
          Left to the reader.
        </p>
      </proof>
    </proposition>
    <proposition xml:id="prop-properties-of-addition-integers">
      <statement>
        <p>
          Let <m>x, y, z \in \Z</m>. Then
          <ol marker="1.">
            <li>
              <p>
                <m>x + (y + z) = (x + y) + z</m>.
              </p>
            </li>
            <li xml:id="li-integer-addition-commutative">
              <p>
                <m>x + y = y + x</m>.
              </p>
            </li>
            <li xml:id="li-zero-additive-identity">
              <p>
                <m>x + \overline{0} = x</m>.
              </p>
            </li>
            <li xml:id="li-x-minus-x-is-0">
              <p>
                <m>x - x = \overline{0}</m>.
              </p>
            </li>
          </ol>
        </p>
      </statement>
      <proof>
        <p>
          Left to the reader 
          (<xref first="hw-01-integer-addition-commutative"
          last="hw-01-x-minus-x-is-0"/>).
        </p>
      </proof>
    </proposition>
    <definition xml:id="def-multiplication-integers">
      <statement>
        <p>
          Define multiplication <m>\cdot \colon \Z \times \Z \to \Z</m> by
          <me>
            [(a, b)] \cdot [(c, d)] = [(ac + bd, ad + bc)]
          </me>.
        </p>
      </statement>
    </definition>
    <proposition xml:id="prop-mul-integers-well-defined-properties">
      <statement>
        <p>
          Multiplication is well-defined and satisfies the following for
          all <m>x, y, z \in \Z</m>.
          <ol marker="1.">
            <li>
              <p>
                <m>(xy)z = x(yz)</m>
              </p>
            </li>
            <li>
              <p>
                <m>x \cdot \overline{1} = x</m>
              </p>
            </li>
            <li>
              <p>
                <m>xy = yx</m>
              </p>
            </li>
            <li>
              <p>
                <m>x(y + z) = xy + xz</m>
              </p>
            </li>
            <li>
              <p>
                If <m>xy = \overline{0}</m> then either <m>x = \overline{0}</m>
                or <m>y = \overline{0}</m>.
              </p>
            </li>
          </ol>
        </p>
      </statement>
      <proof>
        <p>
          Left to the reader (see <xref ref="subsec-hw-01" text="title"/>).
        </p>
      </proof>
    </proposition>
    <definition xml:id="def-integer-less-than">
      <statement>
        <p>
          For <m>[(a,b)], [(c,d)] \in \Z</m>, define <m>[(a, b)] \lt [(c, d)]</m>
          if <m>a + d \lt b + c</m>, that is, if <m>b + c = a + d + k</m>
          for some <m>k \in \N</m>.
        </p>
      </statement>
    </definition>
    <proposition xml:id="prop-natural-integer-inclusion">
      <statement>
        <p>
          Define the function <m>i \colon \N \to \Z</m> by <m>i(n) = [(n+1, 1)]</m>.
          Then it satisfies the following.
          <ol marker="(1)">
            <li xml:id="li-inc-n-z-injective">
              <p>
                The function <m>i</m> is injective.
              </p>
            </li>
            <li xml:id="li-inc-1-1">
              <p>
                <m>i(1) = \overline{1}</m>.
              </p>
            </li>
            <li xml:id="li-inc-n-positive">
              <p>
                <m>i(\N) = \{ x \in \Z : x \gt \overline{0} \}</m>.
              </p>
            </li>
            <li xml:id="li-inc-morphism">
              <p>
                For <m>a, b \in \N</m> we have <m>i(a + b) = i(a) + i(b)</m>,
                <m>i(ab) = i(a)i(b)</m>, and <m>a \lt b</m> if and only if
                <m>i(a) \lt i(b)</m>.
              </p>
            </li>
          </ol>
        </p>
      </statement>
      <proof>
        <p>
          For <xref ref="li-inc-n-z-injective" text="local"/>, suppose that
          <m>i(a) = i(b)</m>. Then <me>
            [(a + 1, 1)] = [(b + 1, 1)]
          </me>. This means, by definition, that <m>a + 1 + 1 = b + 1 + 1</m>,
          whence <m>a = b</m>.
        </p>
        <p>
          For <xref ref="li-inc-1-1" text="local"/>, observe that
          <me>
            i(1) = [(2, 1)] = \overline{1}
          </me>.
        </p>
        <p>
          For <xref ref="li-inc-n-positive" text="local"/>, choose
          <m>x \in i(\N)</m>. We'll show that <m>\overline{0} \lt x</m>. Indeed,
          we have <m>x = [(n + 1, 1)]</m> for some <m>n \in \N</m>. Therefore,
          <md>
            <mrow>n + 2 \amp = 2 + n \implies 2 \lt n + 2 \implies [(1, 1)] \lt [(n + 1, 1)]</mrow>
            <mrow> \amp \implies \overline{0} \lt x. </mrow>
          </md>
          Conversely, suppose now that <m>x = [(a, b)] \gt \overline{0}</m>.
          Then
          <md>
            <mrow>[(1, 1)] \amp \lt [(a, b)] \implies 1 + b \lt 1 + a \implies 1 + a = 1 + b + k \text{ for some $k \in \N$}</mrow>
            <mrow> \amp \implies [(a, b)] = [(k+1, 1)] \in i(\N)</mrow>.
          </md>
        </p>
      </proof>
    </proposition>
    <p>
      We use <m>i</m> to think of <m>\N</m> as a particular subset of <m>\Z</m>
      and we also write
      <md>
        <mrow>\amp \vdots</mrow>
        <mrow>-2 \amp = [(1, 3)]</mrow>
        <mrow>-1 \amp = [(1, 2)]</mrow>
        <mrow>0 \amp = [(1, 1)]</mrow>
        <mrow>1 \amp = [(2, 1)]</mrow>
        <mrow>\amp \vdots</mrow>
      </md>
    </p>
  </subsection>
</section>
